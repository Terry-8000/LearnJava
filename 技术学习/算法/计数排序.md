# java排序之计数排序

### 计数排序思路

它是一个不需要比较的，类似于桶排序的线性时间排序算法。该算法是对已知数量范围的数组进行排序。其时间复杂度为O(n)，适用于知道范围集合的排序。比如100万学生参加高考，我们想对这100万学生的数学成绩（假设分数为0到100）做个排序。 
**基本思想：** 
对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数 。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。它创建一个长度为这个数据范围的数组C，C中每个元素记录要排序数组中对应记录的出现个数。 

**时间复杂度：O(n)    最好情况：O(n)    最坏情况：O(n)**

**空间复杂度：O(n)**

**稳定性：稳定**

**复杂性：简单**

### Java代码实现

```java
 package com.wangjun.arithmetic;

import java.util.Arrays;

/*
 * 计数排序算法
 * 给定一个数组，且知道所有值得范围是[m,n],使用计数排序算法可以使时间复杂度为O(N)
 * 
 * 思路：
 * 新建一个长度为n-m+1的临时数组
 * 遍历待排序数组，它的值-m作为临时数组下角标，这个位置的值加1
 * 遍历结束，临时数组就存储了每个值得个数
 * 最后将它展开赋值给原数组
 * 
 * 参考：https://blog.csdn.net/gaoruxue918/article/details/61467416
 */
public class SortCount {

	public static void main(String[] args) {
		//测试
		int[] arr = {1,4,6,7,5,4,3,2,1,4,5,10,9,10,3};
		sortCount(arr, 1, 10);
		System.out.println(Arrays.toString(arr));
	}
	
	//计数排序的初步实现，使用了多余的空间
	//TODO 优化算法，不使用多余的空间
	public static void sortCount(int[] arr, int m, int n) {
		int len = arr.length;
		int[] tem = new int[n - m + 1];
		for(int i = 0; i < len; i++) {
			tem[arr[i] - m] += 1;
		}
		for(int i = 0, index = 0; i < tem.length; i++) {
			int item = tem[i];
			while(item-- != 0) {
				arr[index++] = i + m;
			}
		}
	}

} 

```

