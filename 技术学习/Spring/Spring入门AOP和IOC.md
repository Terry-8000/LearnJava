# Spring入门AOP和IOC

### 概述

Spring框架的核心有两个：

- Spring容器作为超级大工厂，负责管理、创建所有的Java对象，这些Java对象被称为Bean。

- Spring容器管理容器中Bean之间的依赖关系，使用一种叫做“依赖注入”的方式来管理bean之间的依赖关系。

Spring有两个核心接口：`BeanFactory`和`ApplicationContext`,`ApplicationContext`是`BeanFactory`的子接口、它们都可以代表Spring容器，Spring容器是生成Bean实例的工厂，并管理容器中的Bean。建议优先使用ApplicationContext。除非对内存非常关键的应用再考虑使用BeanFactory。当系统创建ApplicationContext的时候，默认会预初始化所有Singleton Bean，这就意味着前期创建ApplicationContext时将有较大的性能开销，但一旦ApplicationContext初始化完成，程序后面获取singleton Bean实例时，就拥有较好的性能。为`<bean/>`元素指定`lazy-init="true"`那么就不会预初始化Singleton bean了。

### IOC

Inversion Of Control，控制反转，也可以叫依赖注入。A对象需要调用B对象的方法的情景，这种情形称为依赖，即A对象依赖B对象。使用依赖注入不仅可以为Bean对象注入普通的属性值，还可以注入其他Bean引用。通过这种依赖注入，Java EE应用中的各种组件不需要以硬编码方式耦合在一起，甚至无需使用工厂模式。当某个Java实例需要其他Java实例时，系统自动提供所需要的实例，无需程序显式获取。

**好处**

先来说说传统使用java实例的不足，一般有两种方式：

- 通过new关键字实例化一个对象；
- 通过工厂模式生产一个实例对象；

第一种方式必然导致调用者和被依赖对象存在硬编码耦合，非常不利于项目升级的维护；第二种比第一种好很多，但是调用组件需要主动通过工厂去获取被依赖的对象，这就会带来调用组件与被依赖工厂的耦合。

那么IOC有什么好处呢?

调用者无需主动获取被依赖的对象，只要被动接受Spring容器为调用者的成员变量即可。总体来说就是主动变为被动，所以被称为控制反转。

**场景**

依赖注入一般有以下两种：

- 设值注入：IoC容器使用成员变量的setter方法来注入被依赖对象；
- 构造注入：IoC容器通过构造器来注入被依赖对象；

建议采用设值注入为主，构造注入为辅的注入策略。对于依赖关系无需变化的注入，尽量采用构造注入；而其他依赖关系的注入，则考虑采用设值注入。

使用IoC容器的三个基本要点：

- 应用程序的各组件面向接口编程，这样就可以将组件之间的耦合关系提升到接口层次，从而有有利于项目后期的发展；
- 应用程序的各组件不再由程序主动创建，而是由Spring容器来负责产生并初始化；
- Spring采用配置文件或注解来管理Bean的实现类、依赖关系，Spring容器则根据配置文件或注解，利用反射来创建实例，并为之注入依赖关系。



### AOP

Aspect Oriented Programming，面向切面编程，用于在模块化方面的横切关注点。AOP和OOP（Object Oriented Programming）互为补充，可以这么理解：面向对象编程是从静态角度考虑程序结构，面向切面编程则是从动态角度考虑运行过程。

简单的说，它是一个拦截器可以拦截一些过程，当一个方法执行，Spring AOP可以拦截一个方法的执行，在这个方法执行的前后添加一些功能。

在Spring AOP中，支持4种类型的通知：

- 通知(Advice)之前 - 该方法执行前运行
- 通知(Advice)返回之后 – 运行后，该方法返回一个结果
- 通知(Advice)抛出之后 – 运行方法抛出异常后，
- 环绕通知 – 环绕方法执行运行，结合以上这三个通知。

通过通知Advice可以监听所有方法，但是如果只需要监听特定方法呢，这个时候就需要引入“切入点”了，它允许通过它的方法名来拦截方法，另外一个切入点必须和一个Advisor相关联。

在Spring AOP中，有三个非常专业术语- Advice, Yiibaicut , Advisor：

- Advice – 指示之前或方法执行后采取的行动。
- Yiibaicut – 指明哪些方法应该拦截，通过方法的名称或正则表达式模式。
- Advisor – 分组"通知"和”切入点“成为一个单元，并把它传递到代理工厂对象。

**使用场景**

日志记录、审计、声明式事务、安全性和缓存等。

**AspectJ和Spring AOP的区别**

两种实现AOP的方式。

AspectJ是静态实现AOP的，即在编译阶段对程序进行修改，需要特殊的编译器，具有较好的性能；

Spring AOP是动态实现AOP的，即在运行阶段动态生成AOP代理，纯java实现，因此无需特殊的编译器，但是通常性能较差。

目前Spring已经对AspectJ进行了很好的继承。

**相关术语**

- 切面（Aspect）
- 连接点（JoinPoint）
- 增强处理（Advice）
- 切入点（Pointcut）

**Spring实现AOP的方式**

- 基于注解的“零配置”方式：使用@Aspect、@Pointcut等注解标注切入点和增强处理；
- 基于XML配置文件的管理方式：使用Spring配置文件来定义切入点和增强处理；



### 学习路径

构建AOP和IOC的demo；

安装spring工具套件STS；

